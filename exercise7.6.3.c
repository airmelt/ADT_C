// 有一种简单的排序算法,叫做计数排序(count sorting).这种排序算法对一个待排序
// 的表(用数组表示)进行排序,并将排序结果存放到另一个新的表中.必须注意的是,表
// 中所有待排序的关键码互不相同,计数排序算法针对表中的每个记录,扫描待排序的
// 表一趟,统计表中有多少个记录的关键码比该记录的关键码小,假设针对某一个记录,
// 统计出的计数值为c,那么,这个记录在新的有序表中的合适的存放位置即为c
// 与简单选择排序相比较,这种方法是否更好,为什么?
// 时间复杂度O(n^2) 空间复杂度O(n)
// 比较次数为n^2
void CountSort(RecType A[], RecType B[], int n) {
	int cnt;
	for (int i = 0; i < n; i++) {
		for (int j = 0, cnt = 0; j < n; j++)
			if (A[j].key < A[i].key) cnt++;
		B[cnt] = A[i];
	}
}
// 简单选择排序的比较次数为n(n - 1) / 2,简单排序更好